<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@awslabs-community-fork/dynamodb-data-mapper</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@awslabs-community-fork/dynamodb-data-mapper</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> @awslabs-community-fork/dynamodb-data-mapper</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="amazon-dynamodb-datamapper">Amazon DynamoDB DataMapper</h1>
				<p><a href="http://aws.amazon.com/apache-2-0/"><img src="https://img.shields.io/github/license/awslabs/dynamodb-data-mapper-js.svg?style=flat" alt="Apache 2 License"></a></p>
				<p>This library provides a <code>DataMapper</code> class that allows easy interoperability
					between your application&#39;s domain classes and their persisted form in Amazon
					DynamoDB. Powered by the <code>@awslabs-community-fork/dynamodb-data-marshaller</code> and
					<code>@awslabs-community-fork/dynamodb-expressions</code> packages, using <code>DataMapper</code> lets you define each
					object&#39;s persisted representation once and then load, save, scan, and query your
					tables using the vocabulary of your application domain rather than its
				representation in DynamoDB.</p>
				<h2 id="getting-started">Getting started</h2>
				<p>To use the <code>DataMapper</code> with a given JavaScript class, you will need to add a
					couple properties to the prototype of the class you would like to map to a
					DynamoDB table. Specifically, you will need to provide a schema and the name of
				the table:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> {DynamoDbSchema, DynamoDbTable} <span class="hljs-keyword">from</span> <span class="hljs-string">'@awslabs-community-fork/dynamodb-data-mapper'</span>;

<span class="hljs-keyword">class</span> MyDomainModel {
    <span class="hljs-comment">// declare methods and properties as normal</span>
}

<span class="hljs-built_in">Object</span>.defineProperties(MyDomainModel.prototype, {
    [DynamoDbTable]: {
        value: <span class="hljs-string">'MyTable'</span>
    },
    [DynamoDbSchema]: {
        value: {
            id: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>,
                keyType: <span class="hljs-string">'HASH'</span>
            },
            foo: {<span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>},
            bar: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'Set'</span>,
                memberType: <span class="hljs-string">'String'</span>,
            },
            baz: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'Tuple'</span>,
                members: [
                    {<span class="hljs-keyword">type</span>: <span class="hljs-string">'Boolean'</span>},
                    {<span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>},
                ],
            },
        },
    },
});
</code></pre>
				<p>The schema and table name may be declared as property accessors directly on the
				class if the value should be determined dynamically:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> {DynamoDbTable} <span class="hljs-keyword">from</span> <span class="hljs-string">'@awslabs-community-fork/dynamodb-data-mapper'</span>;

<span class="hljs-keyword">class</span> MyOtherDomainClass {
    id: <span class="hljs-built_in">number</span>;

    <span class="hljs-keyword">get</span> [DynamoDbTable]() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">'evens'</span> : <span class="hljs-string">'odds'</span>;
    }
}
</code></pre>
				<p>Next, create an instance of <code>DataMapper</code> and use the <code>MyDomainClass</code> constructor
				defined above to save and load objects from DynamoDB:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> {
    DataMapper,
    DynamoDbSchema,
    DynamoDbTable,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@awslabs-community-fork/dynamodb-data-mapper'</span>;
<span class="hljs-keyword">import</span> DynamoDB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'aws-sdk/clients/dynamodb'</span>);

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> DynamoDB({region: <span class="hljs-string">'us-west-2'</span>});
<span class="hljs-keyword">const</span> mapper = <span class="hljs-keyword">new</span> DataMapper({client});

<span class="hljs-keyword">class</span> MyDomainModel {
    id: <span class="hljs-built_in">string</span>;
    foo?: <span class="hljs-built_in">string</span>;
    bar?: Set&lt;<span class="hljs-built_in">string</span>&gt;;
    baz?: [<span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">string</span>];
}

<span class="hljs-built_in">Object</span>.defineProperties(MyDomainModel.prototype, {
    [DynamoDbTable]: {
        value: <span class="hljs-string">'MyTable'</span>
    },
    [DynamoDbSchema]: {
        value: {
            id: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>,
                keyType: <span class="hljs-string">'HASH'</span>
            },
            foo: {<span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>},
            bar: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'Set'</span>,
                memberType: <span class="hljs-string">'String'</span>,
            },
            baz: {
                <span class="hljs-keyword">type</span>: <span class="hljs-string">'Tuple'</span>,
                members: [
                    {<span class="hljs-keyword">type</span>: <span class="hljs-string">'Boolean'</span>},
                    {<span class="hljs-keyword">type</span>: <span class="hljs-string">'String'</span>},
                ],
            },
        },
    },
});

<span class="hljs-comment">// delete an object</span>
<span class="hljs-keyword">const</span> toDelete = <span class="hljs-keyword">new</span> MyDomainModel();
toDelete.id = <span class="hljs-string">'DELETE_ME'</span>;
mapper.delete(toDelete);

<span class="hljs-comment">// if that's too verbose, you can write the above as a single expression with</span>
<span class="hljs-comment">// Object.assign:</span>
mapper.delete(<span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">new</span> MyDomainModel(), {id: <span class="hljs-string">'DELETE_ME'</span>}));

<span class="hljs-comment">// fetch an object</span>
<span class="hljs-keyword">const</span> toGet = <span class="hljs-keyword">new</span> MyDomainModel();
toGet.id = <span class="hljs-string">'ID_TO_FETCH'</span>;
<span class="hljs-keyword">const</span> fetched = <span class="hljs-keyword">await</span> mapper.get(toGet);

<span class="hljs-comment">// this should return a rejected promise, as it's fetching an object that does</span>
<span class="hljs-comment">// not exist</span>
mapper.get(toDelete)
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I expected this to happen'</span>));

<span class="hljs-comment">// put something new into the database</span>
<span class="hljs-keyword">const</span> toPut = <span class="hljs-keyword">new</span> MyDomainModel();
toPut.id = <span class="hljs-string">'NEW_RECORD'</span>;
toPut.foo = <span class="hljs-string">'bar'</span>;
toPut.bar = <span class="hljs-keyword">new</span> Set&lt;<span class="hljs-built_in">string</span>&gt;([<span class="hljs-string">'fizz'</span>, <span class="hljs-string">'buzz'</span>, <span class="hljs-string">'pop'</span>]);
toPut.baz = [<span class="hljs-literal">true</span>, <span class="hljs-string">'quux'</span>];

mapper.put(toPut).then(<span class="hljs-function">(<span class="hljs-params">persisted: MyDomainModel</span>) =&gt;</span> {
    <span class="hljs-comment">// now change the record a bit</span>
    <span class="hljs-keyword">const</span> toUpdate = <span class="hljs-keyword">new</span> MyDomainModel();
    toUpdate.id = persisted.id;
    toUpdate.baz = [<span class="hljs-literal">false</span>, <span class="hljs-string">'beep'</span>];
    <span class="hljs-keyword">return</span> mapper.update(toUpdate, {onMissing: <span class="hljs-string">'skip'</span>});
});
</code></pre>
				<h2 id="supported-operations">Supported operations</h2>
				<h3 id="batchdelete"><code>batchDelete</code></h3>
				<p>Deletes any number of items from one or more tables in batches of 25 or fewer
					items. Unprocessed deletes are retried following an exponentially increasing
				backoff delay that is applied on a per-table basis.</p>
				<p>Returns an async iterable of items that have been deleted (deleted items are
					yielded when the delete has been accepted by DynamoDB). The results can be
					consumed with a <code>for-await-of</code> loop. If you are using TypeScript, you will need
					to include <code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes one parameter:</p>
				<ul>
					<li>An iterable (synchronous or asynchronous) of items to delete. Each item must
						be an instance of a class with a table name accessible via a property
						identified with the <code>DynamoDbTable</code> symbol and a schema accessible via a
					property identified with the <code>DynamoDbSchema</code> symbol.</li>
				</ul>
				<h3 id="batchget"><code>batchGet</code></h3>
				<p>Fetches any number of items from one or more tables in batches of 100 or fewer
					items. Unprocessed reads are retried following an exponentially increasing
				backoff delay that is applied on a per-table basis.</p>
				<p>Takes two parameters:</p>
				<ul>
					<li><p>An iterable (synchronous or asynchronous) of items to fetch. Each item must be
							an instance of a class with a table name accessible via a property
							identified with the <code>DynamoDbTable</code> symbol and a schema accessible via a
						property identified with the <code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly consistent
									read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an eventually
								consistent read.</p>
							</li>
							<li><p><code>perTableOptions</code> - An object whose keys are table names and whose values
								are objects specifying any of the following options:</p>
								<ul>
									<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly
											consistent read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an
										eventually consistent read.</p>
									</li>
									<li><p><code>projection</code> - A projection expression directing DynamoDB to return a
											subset of the fetched item&#39;s attributes. Please refer to the
											documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for
										guidance on creating projection expression objects.</p>
									</li>
									<li><p><code>projectionSchema</code> - The schema to use when mapping the supplied
										<code>projection</code> option to the attribute names used in DynamoDB.</p>
										<p>  This parameter is only necessary if a batch contains items from
											multiple classes that map to the <em>same</em> table using <em>different</em>
										property names to represent the same DynamoDB attributes.</p>
										<p>  If not supplied, the schema associated with the first item
										associated with a given table will be used in its place.</p>
									</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<h3 id="batchput"><code>batchPut</code></h3>
				<p>Puts any number of items to one or more tables in batches of 25 or fewer items.
					Unprocessed puts are retried following an exponentially increasing backoff delay
				that is applied on a per-table basis.</p>
				<p>Returns an async iterable of items that have been put (put items are yielded
					when the put has been accepted by DynamoDB). The results can be consumed with a
					<code>for-await-of</code> loop. If you are using TypeScript, you will need to include
					<code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes one parameter:</p>
				<ul>
					<li>An iterable (synchronous or asynchronous) of items to put. Each item must be
						an instance of a class with a table name accessible via a property
						identified with the <code>DynamoDbTable</code> symbol and a schema accessible via a
					property identified with the <code>DynamoDbSchema</code> symbol.</li>
				</ul>
				<h3 id="batchwrite"><code>batchWrite</code></h3>
				<p>Puts or deletes any number of items to one or more tables in batches of 25 or
					fewer items. Unprocessed writes are retried following an exponentially
				increasing backoff delay that is applied on a per-table basis.</p>
				<p>Returns an async iterable of tuples of the string &#39;put&#39;|&#39;delete&#39; and the item on
					which the specified write action was performed. The results can be consumed with
					a <code>for-await-of</code> loop. If you are using TypeScript, you will need to include
					<code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes one parameter:</p>
				<ul>
					<li>An iterable (synchronous or asynchronous) of tuples of the string
						&#39;put&#39;|&#39;delete&#39; and the item on which to perform the specified write action.
						Each item must be an instance of a class with a table name accessible via a
						property identified with the <code>DynamoDbTable</code> symbol and a schema accessible
					via a property identified with the <code>DynamoDbSchema</code> symbol.</li>
				</ul>
				<h3 id="delete"><code>delete</code></h3>
				<p>Removes an item from a DynamoDB table. Takes two parameters:</p>
				<ul>
					<li><p>The item to be deleted. Must be an instance of a class with a table name
							accessible via a property identified with the <code>DynamoDbTable</code> symbol and a
							schema accessible via a property identified with the <code>DynamoDbSchema</code>
						symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>condition</code> - A condition expression whose assertion must be satisfied in
									order for the delete operation to be executed. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating condition expression objects.</p>
							</li>
							<li><p><code>returnValues</code> - Specify <code>&#39;ALL_OLD&#39;</code> to have the deleted item returned to
								you when the delete operation completes.</p>
							</li>
							<li><p><code>skipVersionCheck</code> - Whether to forgo creating a condition expression
								based on a defined <code>versionAttribute</code> in the schema.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h3 id="get"><code>get</code></h3>
				<p>Fetches an item from a DynamoDB table. If no item with the specified key was
					found, the returned promise will be rejected with an error. Takes two
				parameters:</p>
				<ul>
					<li><p>The item to be fetched. Must be an instance of a class with a table name
							accessible via a property identified with the <code>DynamoDbTable</code> symbol and a
							schema accessible via a property identified with the <code>DynamoDbSchema</code>
						symbol.</p>
						<p>  The supplied item will <strong>NOT</strong> be updated in place. Rather, a new item of
						the same class with data from the DynamoDB table will be returned.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly consistent
									read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an eventually
								consistent read.</p>
							</li>
							<li><p><code>projection</code> - A projection expression directing DynamoDB to return a
									subset of the fetched item&#39;s attributes. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating projection expression objects.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h3 id="put"><code>put</code></h3>
				<p>Inserts an item into a DynamoDB table. Takes two parameters:</p>
				<ul>
					<li><p>The item to be inserted. Must be an instance of a class with a table name
							accessible via a property identified with the <code>DynamoDbTable</code> symbol and a
							schema accessible via a property identified with the <code>DynamoDbSchema</code>
						symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>condition</code> - A condition expression whose assertion must be satisfied in
									order for the put operation to be executed. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating condition expression objects.</p>
							</li>
							<li><p><code>returnValues</code> - Specify <code>&#39;ALL_OLD&#39;</code> to have the overwritten item (if one
								existed) returned to you when the put operation completes.</p>
							</li>
							<li><p><code>skipVersionCheck</code> - Whether to forgo creating a condition expression
								based on a defined <code>versionAttribute</code> in the schema.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h3 id="query"><code>query</code></h3>
				<p>Retrieves multiple values from a table or index based on the primary key
					attributes. Queries must target a single partition key value but may read
				multiple items with different range keys.</p>
				<p>This method is implemented as an async iterator and the results can be consumed
					with a <code>for-await-of</code> loop. If you are using TypeScript, you will need to
					include <code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes three parameters:</p>
				<ul>
					<li><p>The constructor function to use for any results returned by this operation.
							Must have a prototype with a table name accessible via a property identified
							with the <code>DynamoDbTable</code> symbol and a schema accessible via a property
						identified with the <code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>The condition that specifies the key value(s) for items to be retrieved by the
							query operation. You may provide a hash matching key properties to the
							values they must equal, a hash matching keys to
							<code>ConditionExpressionPredicate</code>s, or a fully composed <code>ConditionExpression</code>.
							If a hash is provided, it may contain a mixture of condition expression
						predicates and exact value matches:</p>
						<pre><code class="lang-typescript">  <span class="hljs-keyword">import</span> {between} <span class="hljs-keyword">from</span> <span class="hljs-string">'@awslabs-community-fork/dynamodb-expressions'</span>;

  <span class="hljs-keyword">const</span> keyCondition = {
      partitionKey: <span class="hljs-string">'foo'</span>,
      rangeKey: between(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>),
  };
</code></pre>
						<p>  The key condition must target a single value for the partition key.</p>
						<p>  Please refer to the documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code>
						package for guidance on creating condition expression objects.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>filter</code> - A condition expression that DynamoDB applies after the Query
									operation, but before the data is returned to you. Items that do not
								satisfy the <code>filter</code> criteria are not returned.</p>
								<p>  You cannot define a filter expression based on a partition key or a sort
								key.</p>
								<p>  Please refer to the documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code>
								package for guidance on creating condition expression objects.</p>
							</li>
							<li><p><code>indexName</code> - The name of the index against which to execute this query.
								If not specified, the query will be executed against the base table.</p>
							</li>
							<li><p><code>limit</code> - The maximum number of items to return.</p>
							</li>
							<li><p><code>pageSize</code> - The maximum number of items to return <strong>per page of results</strong>.</p>
							</li>
							<li><p><code>projection</code> - A projection expression directing DynamoDB to return a
									subset of any fetched item&#39;s attributes. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating projection expression objects.</p>
							</li>
							<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly consistent
									read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an eventually
								consistent read.</p>
							</li>
							<li><p><code>scanIndexForward</code> - Specifies the order for index traversal: If true, the
									traversal is performed in ascending order; if false, the traversal is
								performed in descending order.</p>
							</li>
							<li><p><code>startKey</code> - The primary key of the first item that this operation will
								evaluate.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h4 id="query-metadata">Query metadata</h4>
				<p>The iterator returned by <code>query</code> will keep track of the number of items yielded
				and the number of items scanned via its <code>count</code> and <code>scannedCount</code> properties:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> iterator = mapper.query(
    MyClass,
    {partitionKey: <span class="hljs-string">'foo'</span>, rangeKey: between(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)}
);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> record of iterator) {
    <span class="hljs-built_in">console</span>.log(record, iterator.count, iterator.scannedCount);
}
</code></pre>
				<h4 id="pagination">Pagination</h4>
				<p>If you wish to perform a resumable query, you can use the <code>.pages()</code> method of
					the iterator returned by <code>query</code> to access the underlying paginator. The
					paginator differs from the iterator in that it yields arrays of unmarshalled
					records and has a <code>lastEvaluatedKey</code> property that may be provided to a new
				call to <code>mapper.query</code> to resume the query later or in a separate process:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> paginator = mapper.query(
    MyClass,
    {partitionKey: <span class="hljs-string">'foo'</span>, rangeKey: between(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)},
    {
        <span class="hljs-comment">// automatically stop after 25 items or the entire result set has been</span>
        <span class="hljs-comment">// fetched, whichever is smaller</span>
        limit: <span class="hljs-number">25</span>
    }
).pages();

<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> page of paginator) {
    <span class="hljs-built_in">console</span>.log(
        paginator.count,
        paginator.scannedCount,
        paginator.lastEvaluatedKey
    );
}

<span class="hljs-keyword">const</span> newPaginator = mapper.query(
    MyClass,
    {partitionKey: <span class="hljs-string">'foo'</span>, rangeKey: between(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)},
    {
        <span class="hljs-comment">// start this new paginator where the previous one stopped</span>
        startKey: paginator.lastEvaluatedKey
    }
).pages();
</code></pre>
				<h3 id="scan"><code>scan</code></h3>
				<p>Retrieves all values in a table or index.</p>
				<p>This method is implemented as an async iterator and the results can be consumed
					with a <code>for-await-of</code> loop. If you are using TypeScript, you will need to
					include <code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes two parameters:</p>
				<ul>
					<li><p>The constructor function to use for any results returned by this operation.
							Must have a prototype with a table name accessible via a property identified
							with the <code>DynamoDbTable</code> symbol and a schema accessible via a property
						identified with the <code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>filter</code> - A condition expression that DynamoDB applies after the scan
									operation, but before the data is returned to you. Items that do not
								satisfy the <code>filter</code> criteria are not returned.</p>
								<p>  You cannot define a filter expression based on a partition key or a sort
								key.</p>
								<p>  Please refer to the documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code>
								package for guidance on creating condition expression objects.</p>
							</li>
							<li><p><code>indexName</code> - The name of the index against which to execute this query.
								If not specified, the query will be executed against the base table.</p>
							</li>
							<li><p><code>limit</code> - The maximum number of items to return.</p>
							</li>
							<li><p><code>pageSize</code> - The maximum number of items to return <strong>per page of results</strong>.</p>
							</li>
							<li><p><code>projection</code> - A projection expression directing DynamoDB to return a
									subset of any fetched item&#39;s attributes. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating projection expression objects.</p>
							</li>
							<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly consistent
									read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an eventually
								consistent read.</p>
							</li>
							<li><p><code>segment</code> - The identifier for this segment (if this scan is being
								performed as part of a parallel scan operation).</p>
							</li>
							<li><p><code>startKey</code> - The primary key of the first item that this operation will
								evaluate.</p>
							</li>
							<li><p><code>totalSegments</code> - The number of segments into which this scan has been
									divided (if this scan is being performed as part of a parallel scan
								operation).</p>
							</li>
						</ul>
					</li>
				</ul>
				<h4 id="scan-metadata">Scan metadata</h4>
				<p>The iterator returned by <code>scan</code> will keep track of the number of items yielded
				and the number of items scanned via its <code>count</code> and <code>scannedCount</code> properties:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> iterator = mapper.scan(MyClass);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> record of iterator) {
    <span class="hljs-built_in">console</span>.log(record, iterator.count, iterator.scannedCount);
}
</code></pre>
				<h4 id="pagination">Pagination</h4>
				<p>If you wish to perform a resumable scan, you can use the <code>.pages()</code> method of
					the iterator returned by <code>scan</code> to access the underlying paginator. The
					paginator differs from the iterator in that it yields arrays of unmarshalled
					records and has a <code>lastEvaluatedKey</code> property that may be provided to a new
				call to <code>mapper.scan</code> to resume the scan later or in a separate process:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> paginator = mapper.scan(
    MyClass,
    {
        <span class="hljs-comment">// automatically stop after 25 items or the entire result set has been</span>
        <span class="hljs-comment">// fetched, whichever is smaller</span>
        limit: <span class="hljs-number">25</span>
    }
).pages();
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> page of paginator) {
    <span class="hljs-built_in">console</span>.log(
        paginator.count,
        paginator.scannedCount,
        paginator.lastEvaluatedKey
    );
}

<span class="hljs-keyword">const</span> newPaginator = mapper.scan(
    MyClass,
    {
        <span class="hljs-comment">// start this new paginator where the previous one stopped</span>
        startKey: paginator.lastEvaluatedKey
    }
).pages();
</code></pre>
				<h3 id="parallelscan"><code>parallelScan</code></h3>
				<p>Retrieves all values in a table by dividing the table into segments, all of
				which are scanned in parallel.</p>
				<p>This method is implemented as an async iterator and the results can be consumed
					with a <code>for-await-of</code> loop. If you are using TypeScript, you will need to
					include <code>esnext.asynciterable</code> in your <code>lib</code> declaration (as well as enabling
					<code>downlevelIteration</code> if targeting ES5 or lower). Please refer to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#async-iteration">the TypeScript
					release notes</a>
				for more information.</p>
				<p>Takes three parameters:</p>
				<ul>
					<li><p>The constructor to use for any results returned by this operation. Must have a
							prototype with a table name accessible via a property identified with the
							<code>DynamoDbTable</code> symbol and a schema accessible via a property identified
						with the <code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>The total number of parallel workers to use to scan the table.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>filter</code> - A condition expression that DynamoDB applies after the scan
									operation, but before the data is returned to you. Items that do not
								satisfy the <code>filter</code> criteria are not returned.</p>
								<p>  You cannot define a filter expression based on a partition key or a sort
								key.</p>
								<p>  Please refer to the documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code>
								package for guidance on creating condition expression objects.</p>
							</li>
							<li><p><code>indexName</code> - The name of the index against which to execute this query.
								If not specified, the query will be executed against the base table.</p>
							</li>
							<li><p><code>pageSize</code> - The maximum number of items to return <strong>per page of results</strong>.</p>
							</li>
							<li><p><code>projection</code> - A projection expression directing DynamoDB to return a
									subset of any fetched item&#39;s attributes. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating projection expression objects.</p>
							</li>
							<li><p><code>readConsistency</code> - Specify <code>&#39;strong&#39;</code> to perform a strongly consistent
									read. Specify <code>&#39;eventual&#39;</code> (the default) to perform an eventually
								consistent read.</p>
							</li>
							<li><p><code>startKey</code> - The primary key of the first item that this operation will
								evaluate.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h4 id="scan-metadata">Scan metadata</h4>
				<p>The iterator returned by <code>parallelScan</code> will keep track of the number of items
					yielded and the number of items scanned via its <code>count</code> and <code>scannedCount</code>
				properties:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> iterator = mapper.parallelScan(MyClass, <span class="hljs-number">4</span>);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> record of iterator) {
    <span class="hljs-built_in">console</span>.log(record, iterator.count, iterator.scannedCount);
}
</code></pre>
				<h4 id="pagination">Pagination</h4>
				<p>If you wish to perform a resumable parallel scan, you can use the <code>.pages()</code>
					method of the iterator returned by <code>parallelScan</code> to access the underlying
					paginator. The  paginator differs from the iterator in that it yields arrays of
					unmarshalled records and has a <code>scanState</code> property that may be provided
					to a new call to <code>mapper.parallelScan</code> to resume the scan later or in a separate
				process:</p>
				<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> paginator = mapper.parallelScan(
    MyClass,
    <span class="hljs-number">4</span>
).pages();
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> page of paginator) {
    <span class="hljs-built_in">console</span>.log(
        paginator.count,
        paginator.scannedCount,
        paginator.lastEvaluatedKey
    );

    <span class="hljs-keyword">break</span>;
}

<span class="hljs-keyword">const</span> newPaginator = mapper.parallelScan(
    MyClass,
    <span class="hljs-number">4</span>,
    {
        <span class="hljs-comment">// start this new paginator where the previous one stopped</span>
        scanState: paginator.scanState
    }
).pages();
</code></pre>
				<h3 id="update"><code>update</code></h3>
				<p>Updates an item in a DynamoDB table. Will leave attributes not defined in the
				schema in place.</p>
				<p>Takes two parameters:</p>
				<ul>
					<li><p>The item with its desired property state. Must be an instance of a class with
							a table name accessible via a property identified with the <code>DynamoDbTable</code>
							symbol and a schema accessible via a property identified with the
						<code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><p><code>condition</code> - A condition expression whose assertion must be satisfied in
									order for the update operation to be executed. Please refer to the
									documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
								on creating condition expression objects.</p>
							</li>
							<li><p><code>onMissing</code> - Specify <code>&#39;remove&#39;</code> (the default) to treat the absence of a
									value in the supplied <code>item</code> as a directive to remove the property from
									the record in DynamoDB. Specify <code>&#39;skip&#39;</code> to only update the properties
								that are defined in the supplied <code>item</code>.</p>
							</li>
							<li><p><code>skipVersionCheck</code> - Whether to forgo creating a condition expression
								based on a defined <code>versionAttribute</code> in the schema.</p>
							</li>
						</ul>
					</li>
				</ul>
				<h3 id="executeupdateexpression"><code>executeUpdateExpression</code></h3>
				<p>Executes a custom update expression. This method will <strong>not</strong> automatically
					apply a version check, as the current state of the object being updated is not
				known.</p>
				<p>Takes four parameters:</p>
				<ul>
					<li><p>The expression to execute. Please refer to the documentation for the
							<code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance on creating update
						expression objects.</p>
					</li>
					<li><p>The key of the item being updated.</p>
					</li>
					<li><p>The constructor for the class mapped to the table against which the expression
							should be run. Must have a prototype with a table name accessible via a
							property identified with the <code>DynamoDbTable</code> symbol and a schema accessible
						via a property identified with the <code>DynamoDbSchema</code> symbol.</p>
					</li>
					<li><p>(Optional) An object specifying any of the following options:</p>
						<ul>
							<li><code>condition</code> - A condition expression whose assertion must be satisfied in
								order for the update operation to be executed. Please refer to the
								documentation for the <code>@awslabs-community-fork/dynamodb-expressions</code> package for guidance
							on creating condition expression objects.</li>
						</ul>
					</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class">
						<a href="classes/datamapper.html" class="tsd-kind-icon">Data<wbr>Mapper</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/itemnotfoundexception.html" class="tsd-kind-icon">Item<wbr>Not<wbr>Found<wbr>Exception</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/iterator.html" class="tsd-kind-icon">Iterator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/paginator.html" class="tsd-kind-icon">Paginator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/parallelscaniterator.html" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Iterator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/parallelscanpaginator.html" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Paginator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/queryiterator.html" class="tsd-kind-icon">Query<wbr>Iterator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/querypaginator.html" class="tsd-kind-icon">Query<wbr>Paginator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/scaniterator.html" class="tsd-kind-icon">Scan<wbr>Iterator</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/scanpaginator.html" class="tsd-kind-icon">Scan<wbr>Paginator</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/basescanoptions.html" class="tsd-kind-icon">Base<wbr>Scan<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/basesequentialscanoptions.html" class="tsd-kind-icon">Base<wbr>Sequential<wbr>Scan<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/batchgetoptions.html" class="tsd-kind-icon">Batch<wbr>Get<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/batchgettableoptions.html" class="tsd-kind-icon">Batch<wbr>Get<wbr>Table<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/batchstate.html" class="tsd-kind-icon">Batch<wbr>State</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/createtableoptions.html" class="tsd-kind-icon">Create<wbr>Table<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/ctorbearer.html" class="tsd-kind-icon">Ctor<wbr>Bearer</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/datamapperconfiguration.html" class="tsd-kind-icon">Data<wbr>Mapper<wbr>Configuration</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/deleteoptions.html" class="tsd-kind-icon">Delete<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/deleteparameters.html" class="tsd-kind-icon">Delete<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/documenttypeoptions.html" class="tsd-kind-icon">Document<wbr>Type<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/executeupdateexpressionoptions.html" class="tsd-kind-icon">Execute<wbr>Update<wbr>Expression<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/getoptions.html" class="tsd-kind-icon">Get<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/getparameters.html" class="tsd-kind-icon">Get<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/globalsecondaryindexoptions.html" class="tsd-kind-icon">Global<wbr>Secondary<wbr>Index<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/initializedscanstate.html" class="tsd-kind-icon">Initialized<wbr>Scan<wbr>State</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/localsecondaryindexoptions.html" class="tsd-kind-icon">Local<wbr>Secondary<wbr>Index<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/parallelscanoptions.html" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/parallelscanworkeroptions.html" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Worker<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/perindexoptions.html" class="tsd-kind-icon">Per<wbr>Index<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/provisionedthroughput.html" class="tsd-kind-icon">Provisioned<wbr>Throughput</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/putoptions.html" class="tsd-kind-icon">Put<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/putparameters.html" class="tsd-kind-icon">Put<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/queryoptions.html" class="tsd-kind-icon">Query<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/queryparameters.html" class="tsd-kind-icon">Query<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/readconsistencyconfiguration.html" class="tsd-kind-icon">Read<wbr>Consistency<wbr>Configuration</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/scanoptions.html" class="tsd-kind-icon">Scan<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/sharedsecondaryindexoptions.html" class="tsd-kind-icon">Shared<wbr>Secondary<wbr>Index<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/stringtoanyobjectmap.html" class="tsd-kind-icon">String<wbr>ToAny<wbr>Object<wbr>Map</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/uninitializedscanstate.html" class="tsd-kind-icon">Uninitialized<wbr>Scan<wbr>State</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/updateoptions.html" class="tsd-kind-icon">Update<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/updateparameters.html" class="tsd-kind-icon">Update<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#onmissingstrategy" class="tsd-kind-icon">On<wbr>Missing<wbr>Strategy</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#parallelscanparameters" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#parallelscanstate" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>State</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#parallelscanworkerparameters" class="tsd-kind-icon">Parallel<wbr>Scan<wbr>Worker<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#readconsistency" class="tsd-kind-icon">Read<wbr>Consistency</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#scanparameters" class="tsd-kind-icon">Scan<wbr>Parameters</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#scanstate" class="tsd-kind-icon">Scan<wbr>State</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#secondaryindexoptions" class="tsd-kind-icon">Secondary<wbr>Index<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#secondaryindexprojection" class="tsd-kind-icon">Secondary<wbr>Index<wbr>Projection</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#sequentialscanoptions" class="tsd-kind-icon">Sequential<wbr>Scan<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#streamviewtype" class="tsd-kind-icon">Stream<wbr>View<wbr>Type</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#syncorasynciterable" class="tsd-kind-icon">Sync<wbr>OrAsync<wbr>Iterable</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#writetype" class="tsd-kind-icon">Write<wbr>Type</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#dynamodbdirtyfields" class="tsd-kind-icon">Dynamo<wbr>DbDirty<wbr>Fields</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#dynamodbschema" class="tsd-kind-icon">Dynamo<wbr>DbSchema</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#dynamodbtable" class="tsd-kind-icon">Dynamo<wbr>DbTable</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#max_read_batch_size" class="tsd-kind-icon">MAX_<wbr>READ_<wbr>BATCH_<wbr>SIZE</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#max_write_batch_size" class="tsd-kind-icon">MAX_<wbr>WRITE_<wbr>BATCH_<wbr>SIZE</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#version" class="tsd-kind-icon">VERSION</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#buildscaninput" class="tsd-kind-icon">build<wbr>Scan<wbr>Input</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#embed" class="tsd-kind-icon">embed</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#getschema" class="tsd-kind-icon">get<wbr>Schema</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#gettablename" class="tsd-kind-icon">get<wbr>Table<wbr>Name</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#marshallstartkey" class="tsd-kind-icon">marshall<wbr>Start<wbr>Key</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer>
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>
